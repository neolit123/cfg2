cfg2 0.22.0 README
a simplistic configuration parser for INI like syntax in ANSI C

last revisited:
	14.10.2015
author:
	lubomir i. ivanov (neolit123 at gmail)

================================================================================
INTRODUCTION:

not being related to other libcfg* projects, cfg2 is a library that can read
a simple configuration format (from file or buffer) and then be used
to retrieve each key/value from memory with optimal performance.

overnight, cfg2 sprung out of annoyances from how badly designed
gettext is (author's opinion). in terms of translation and localization
of individual software products, Windows applications have been using INI
configurations and this seems to be working quite well for a lot
of developers. in comparison, while gettext provides the means to supposedly
ease the whole process, in the long run it ends up being difficult to maintain,
according to a decent amount of people.

example areas are:
	1) .po -> .mo conversations
	2) requires translation tweaks based on source code changes (ouch?)
	3) speed - there are some report that the library is not the most
	efficient

but actually cfg2 is not an alternative to gettext!

strongly designed, legacy games like quake2 have been using a very simple
configuration file format in the lines of "key=value".

cfg2 format example:
--------------------------------------------------------------------------------
[section1]
key1=value1
key2=value2
; a comment line
key3="value \t with some special \n characters"
key4="some value \
on multiple lines"

[section2]
; integer value
key5=-12345678
; floating point value
key6=12345678.312
; hex value
key7=0xfafafafa
; key/value with whitespace
"    key8  "   =   "   value8  "
; HelloWorld as a case-insensitive hex value (needs extra parsing)
key9=48656c6c6f576f726c64

--------------------------------------------------------------------------------

the above pretty much covers what the library can be used for.

format notes:
* UTF-8, LF is the file format! CRLF and CR are pretty much untested.
* since 0.15.0 the supported format structure is close to the INI format
specified here:
    https://en.wikipedia.org/wiki/INI_file
* comment lines still can be defined starting with the ';' character
or a custom character using cfg_t's 'comment_char' field
* the parser does not handle duplicates i.e. memory will be allocated for such;
to separate duplicates use sections
* the parser is not very strict, thus not many errors will be thrown if things
go wrong

================================================================================
WHY WRITE A NEW CONFIG LIBRARY?:

while there are many different configuration formats and parser libraries
out there, the answer is "for fun", but perhaps also for the performance,
portability and overhead benefits. this library is a minimal and very fast
alternative.

================================================================================
HOW IT WORKS:

when reading a buffer with cfg2, first we find how many keys and sections are
there. after we have a number, we allocate lists of values (or pointers)
with that size.

then we go trough the buffer again and store the key values in string buffers
and also calculate hash values for each one (using fnv-32) and assign them
to sections. the is a common performance boost, since when we are looking
for a value in the list we simply compare hash values (32bit integer) instead
of complete strings. this can be considered as a dictionary implementation
yet the source code does not mention it.

the parser uses a trick with special characters to separate sections, keys
and values into a raw buffer. you should look at cfg2.h to find the default
ones set as CFG_KEY_VALUE_SEPARATOR and CFG_SECTION_SEPARATOR. custom ones can
be set into the cfg_t struct as 'key_value_separator' and 'section_separator'
and should be unique for the parser to work!

another present optimization is caching N values in a separate cache buffer and
always checking this buffer first, instead of the main one (which can be huge).
this technique optimizes performance when a value is used multiple times.
the cache buffer can be resized dynamically or disabled when its size is set to
zero.

arrays are used instead of linked lists for performance reasons.

without cache support and all the helper functions the source code can
be squeezed into 200 lines of readable code.

================================================================================
PERFORMANCE:

the library should be pretty fast even without optimization flags. from tests
it takes around 1.4 seconds to parse a 20MB text file with ~550,000 keys and
~80,000 sections on a modern dual core processor.

================================================================================
API:

the API is pretty simple. it uses naming scheme for functions similar to GLib
and the usage logic is quite common as well:
	create a library object
	init/allocate object
	work with object
	free object

for more specific information for each API function take a look at the comments
in "cfg2.h". also a better usage example can be found in "test.c".

small usage example without error checking:
--------------------------------------------------------------------------------
char *k;
cfg_t st; /* library object */

cfg_init(&st, 0); /* init the library */
cfg_parse_file(&st, some_file); /* parse a file */
k = cfg_value_get(&st, "key1"); /* get c string value */
puts(k); /* value1 */
cfg_free(&st);

================================================================================
COMPILATION:

go to the root folder and then:

to create a library file (in ./lib) write:
make lib

to compile the example (in ./test) write:
make test

to run the example write:
make run

at the moment the library makefile can only be used with gcc as
the compiler/linker, but the library is compatible with msvc as well.
to compile with msvc use your prefered toolset (e.g. CL/LINK).

================================================================================
