cfg2 0.30.0 README
a simplistic configuration parser for INI like syntax in C

last revisited:
	20.01.2016
author:
	lubomir i. ivanov (neolit123 at gmail)

================================================================================
INTRODUCTION:

cfg2 is a simple library for parsing and writing a configuration file format
very similar to the INI file format. it's not related to any projects such as
libcfg*. it can be used for very fast processing of application configurations
and even translations.

public domain code - see LICENSE!

cfg2 format example:
--------------------------------------------------------------------------------
[section1]
key1=value1
key2=value2
; a comment line
key3="value with some special \n characters"
key4="some value \
on multiple lines"

[section2]
; integer value
key5=-12345678
; floating point value
key6=12345678.312
; hex value
key7=0xfafafafa
; key/value with whitespace
"    key8  "   =   "   value8  "
; HelloWorld as a case-insensitive hex value (needs extra parsing)
key9=48656c6c6f576f726c64
--------------------------------------------------------------------------------

the above pretty much covers what the library can be used for.

format notes:
* the required file format is UTF-8, LF! CRLF and CR are pretty much untested.
* since 0.15.0 the supported format structure is close to the INI format
specified here:
    https://en.wikipedia.org/wiki/INI_file
* comment lines still can be defined starting with the ';' or '#' characters
or custom characters using cfg_t's 'comment_char[1/2]' fields
* the parser does not handle duplicates i.e. memory will be allocated for such.
to separate duplicates use sections!
* the parser is not very strict, thus not many errors will be thrown if things
go wrong, just warnings if cfg_t's 'verbose' field is more than 0
* \x??[??] sequences are not supported as they take way too much space.
use direct hex strings (e.g. key9) and parse them explicitly with
cfg_hex_to_char().

================================================================================
WHY WRITE A NEW CONFIG LIBRARY?:

while there are many different configuration formats and parser libraries
out there, the answer is "for fun", but perhaps also for the performance,
portability and overhead benefits. this library is a minimal and very fast
alternative.

================================================================================
HOW IT WORKS:

when reading a buffer with cfg2, first we find how many keys and sections are
there. after we have a number, we allocate lists of values (or pointers)
with that size.

then we go trough the buffer again and store the key values in string buffers
and also calculate hash values for each one (using fnv-32) and assign them
to sections. this is a common performance boost, since when we are looking
for a value in the list we simply compare key hashes (32bit integer) instead
of key strings. this can be considered as a dictionary implementation,
yet the source code does not mention it.

the parser uses a trick with special characters to separate sections, keys
and values into a raw buffer. you should look at cfg2.h to find the default
ones set as CFG_KEY_VALUE_SEPARATOR and CFG_SECTION_SEPARATOR. custom ones can
be set into the cfg_t struct as 'key_value_separator' and 'section_separator'
and should be unique for the parser to work!

another present optimization is caching N values in a separate cache buffer and
always checking this buffer first, instead of the main one (which can be huge).
this technique optimizes performance when a value is used multiple times.
the cache buffer can be resized dynamically or disabled when its size is set to
zero.

arrays are used instead of linked lists for performance reasons.

without cache support and all the helper functions the source code can
be squeezed into 200 lines of readable code.

================================================================================
PERFORMANCE:

the library should be pretty fast even without optimization flags. from tests
it takes around 1.4 seconds to parse a 20MB text file with ~550,000 keys and
~80,000 sections on a modern dual core processor.

================================================================================
API:

the API is pretty simple, but mind that it might change here and there until
a "major" version is released. it uses a naming scheme for functions
similar to GLib and the usage logic is quite common as well:
	create a library object
	init/allocate object
	work with object
	free object

for more specific information for each API function take a look at the comments
in "cfg2.h". also a better usage example can be found in "test.c".

small usage example without error checking:
--------------------------------------------------------------------------------
char *v;
cfg_t st; /* library object */

cfg_init(&st); /* init the library */
cfg_parse_file(&st, some_file); /* parse a file */
v = cfg_value_get(&st, "section1", "key1"); /* get a key's value */
puts(v); /* value1 */
cfg_free(&st, CFG_FALSE); /* second argument = don't free 'st' itself */

================================================================================
COMPILATION:

go to the root folder and then:

to create a library file (in ./lib) write:
make lib

to compile the example (in ./test) write:
make test

to run the example write:
make run

at the moment the library makefile can only be used with GCC as
the compiler/linker, but the library is compatible with MSVC as well.
to compile with MSVC use the appropriate toolset (e.g. CL/LINK).

================================================================================
